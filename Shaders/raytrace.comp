#version 450

// =========================================
layout (local_size_x = 16, local_size_y = 16) in;
layout (set = 1, binding = 0, rgba8) uniform image2D resultImage;
layout (set = 1, binding = 1) uniform sampler2D albedoMap;
layout (set = 1, binding = 2) uniform sampler2D metallicMap;

const float epsilon = 0.001f;
const float infinity = 10000.0f;
const float rayNudge = 0.01f;
const float minimumRayHitDist = 0.01f;
const float c_pi = 3.14159265359f;
const float c_twopi = 2.0f * c_pi;

const int DIFF = 0;
const int REFL = 1;
const int REFR = 2;

uint WangHash(inout uint seed)
{
    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));
    seed *= uint(9);
    seed = seed ^ (seed >> 4);
    seed *= uint(0x27d4eb2d);
    seed = seed ^ (seed >> 15);
    return seed;
}

float RandomFloat01(inout uint state)
{
    return float(WangHash(state)) / 4294967296.0; // uint max
}

vec3 RandomUnitVector(inout uint state)
{
    // Uniform sampling of hemisphere
    float z = RandomFloat01(state) * 2.0f - 1.0f;
    float a = RandomFloat01(state) * c_twopi;
    float r = sqrt(1.0f - z * z);
    float x = r * cos(a);
    float y = r * sin(a);
    return vec3(x, y, z);
}

layout (push_constant) uniform PushConstants {
    uint frameNumber;
} pushConstants;

// =========================================
layout (set = 0, binding = 0) uniform Camera
{
    mat4 view;
    mat4 proj;
    mat4 viewProj;
} camera;

// =========================================
// TODO move to a global info
const int MAX_NUM_LIGHTS = 100;
struct Light
{
    vec4 pos;
    vec4 color;
    vec3 dir;
    float intensity;
};

layout (set = 0, binding = 1) uniform Lights
{
    Light lights[MAX_NUM_LIGHTS];
    uint numLights;
} lightBuffer;

struct RayHitInfo
{
    float dist;
    vec3 normal;
    vec3 albedo;
    vec3 emission;
    float specPercentage;
    float ior; // index of refraction
    bool fromInside;
    bool isRefractive;
};

RayHitInfo DefaultRayHitInfo()
{
    RayHitInfo info;

    info.dist = 0.0f;
    info.normal = vec3(0.0f);
    info.albedo = vec3(1.0f);
    info.emission = vec3(0.0f);
    info.specPercentage = 0.0f;
    info.ior = 1.0f;
    info.fromInside = false;
    info.isRefractive = false;

    return info;
}


// =========================================
struct Sphere
{
    vec3 pos;
    float radius;
    vec3 emission;
    vec3 albedo;
    int mat;
    int id;
};


layout (std140, set = 2, binding = 0) buffer Spheres
{
    Sphere spheres[];
};

// =========================================
struct Quad
{
    vec3 a, b, c, d;
    vec3 emission;
    vec3 albedo;
    int mat;
    int id;
};

layout (std140, set = 2, binding = 1) buffer Quads
{
    Quad quads[];
};

float ScalarTriple(vec3 u, vec3 v, vec3 w)
{
    return dot(cross(u,v), w);
}

bool QuadIntersect(
    in vec3 rayPos,
    in vec3 rayDir,
    inout RayHitInfo info,
    in vec3 a,
    in vec3 b,
    in vec3 c,
    in vec3 d)
{
    // calculate normal and flip vertices order if needed
    vec3 normal = normalize(cross(c-a, c-b));
    if (dot(normal, rayDir) > 0.0f)
    {
        normal *= -1.0f;

        vec3 temp = d;
        d = a;
        a = temp;

        temp = b;
        b = c;
        c = temp;
    }

    vec3 p = rayPos;
    vec3 q = rayPos + rayDir;
    vec3 pq = q - p;
    vec3 pa = a - p;
    vec3 pb = b - p;
    vec3 pc = c - p;

    // determine which triangle to test against by testing against diagonal first
    vec3 m = cross(pc, pq);
    float v = dot(pa, m);
    vec3 intersectPos;
    if (v >= 0.0f)
    {
        // test against triangle a,b,c
        float u = -dot(pb, m);
        if (u < 0.0f) return false;
        float w = ScalarTriple(pq, pb, pa);
        if (w < 0.0f) return false;
        float denom = 1.0f / (u+v+w);
        u*=denom;
        v*=denom;
        w*=denom;
        intersectPos = u*a+v*b+w*c;
    }
    else
    {
        vec3 pd = d - p;
        float u = dot(pd, m);
        if (u < 0.0f) return false;
        float w = ScalarTriple(pq, pa, pd);
        if (w < 0.0f) return false;
        v = -v;
        float denom = 1.0f / (u+v+w);
        u*=denom;
        v*=denom;
        w*=denom;
        intersectPos = u*a+v*d+w*c;
    }

    float dist;
    if (abs(rayDir.x) > 0.1f)
    {
        dist = (intersectPos.x - rayPos.x) / rayDir.x;
    }
    else if (abs(rayDir.y) > 0.1f)
    {
        dist = (intersectPos.y - rayPos.y) / rayDir.y;
    }
    else
    {
        dist = (intersectPos.z - rayPos.z) / rayDir.z;
    }

    if (dist > minimumRayHitDist && dist < info.dist)
    {
        info.dist = dist;
        info.normal = normal;
        // TODO needed for 3d polygons, for now set as false since quads are 2d
        info.fromInside = false;
        return true;
    }

    return false;
}

bool SphereIntersect(
    in vec3 rayO,
    in vec3 rayD,
    inout RayHitInfo hitInfo,
    in Sphere sphere)
{
    vec3 oc = rayO - sphere.pos;
    float a = dot(rayD, rayD);
    float b = 2.0f * dot(oc, rayD);
    float c = dot(oc, oc) - sphere.radius*sphere.radius;

    // Roots exist if discriminant value >= 0
    float discr = b*b - 4*a*c;
    if (discr < 0.0f) {
        return false;
    }

    float invDenom = 0.5f / a; // 1/(2a)
    bool isInside = false;
    float dist = (-b - sqrt(discr)) * invDenom;
    if (dist < 0.0f)
    {
        isInside = true;
        dist = (-b + sqrt(discr)) * invDenom;
    }

    // Get closest value of intersection which is stored as lowest t value
    if (dist > minimumRayHitDist && dist < hitInfo.dist)
    {
        hitInfo.dist = dist;
        vec3 hitPos = rayO + dist*rayD;
        hitInfo.normal = normalize(hitPos - sphere.pos)
                       * (isInside ? -1.0f : 1.0f);
        hitInfo.fromInside = isInside;
        return true;
    }

    return false;
}

vec3 GetQuadUv(in vec3 minBound, in vec3 maxBound, in vec3 pos)
{
    vec3 dim = abs(maxBound - minBound);
    vec3 uv = abs(pos - minBound)/dim;
    return uv;
}

vec2 GetSphereUv(in vec3 spherePos, in vec3 hitPos)
{
    // Map to polar coordinates
    //float theta = acos(
    return vec2(0.0f);
}

void CornellBoxSceneIntersection2(in vec3 rayPos, in vec3 rayDir, inout RayHitInfo hitInfo)
{
    // TODO
    //vec3 minBound = vec3(0.0f);
    //vec3 maxBound = vec3(20.0f, 30.0f, -35.0f);

    // back wall
    {
        vec3 A = vec3(-12.6f, -12.6f, -35.0f);
        vec3 B = vec3( 12.6f, -12.6f, -35.0f);
        vec3 C = vec3( 12.6f,  12.6f, -35.0f);
        vec3 D = vec3(-12.6f,  12.6f, -35.0f);
        if (QuadIntersect(rayPos, rayDir, hitInfo, A, B, C, D))
        {
            vec3 uv = GetQuadUv(A, C, (rayPos + hitInfo.dist*rayDir));
            vec2 maxTiles = ivec2(1, 30);
            vec2 scaledUv = uv.xy * maxTiles;
            vec2 iuv = floor(scaledUv);

            float isTiled = mod(iuv.y, 2.0f);
            //isTiled = 0.0f;

            vec3 tileColor = mix(
                    vec3(1.0f,0.8f,0.7f),
                    vec3(0.0f,0.9f,0.1f),
                    isTiled
            );

            if (isTiled == 1.0f) {
                vec3 gradient = vec3(0.1, 0.1, 1.0);
                tileColor = mix(tileColor, gradient, uv.y);
            }
            hitInfo.albedo = tileColor;
            //hitInfo.albedo = vec3(uv.xy, 0.0f);
            hitInfo.emission = mix(vec3(0.0f), tileColor*3.0f, isTiled);
            //hitInfo.emission = vec3(0.0f);
            hitInfo.specPercentage = 0.0f;
            hitInfo.ior = 1.0f;
            hitInfo.isRefractive = false;
        }
    }

    // floor
    {
        vec3 A = vec3(-12.6f, -12.45f, -35.0f);
        vec3 B = vec3( 12.6f, -12.45f, -35.0f);
        vec3 C = vec3( 12.6f, -12.45f, -5.0f);
        vec3 D = vec3(-12.6f, -12.45f, -5.0f);
        if (QuadIntersect(rayPos, rayDir, hitInfo, A, B, C, D))
        {
            vec3 uv = GetQuadUv(D, B, (rayPos + hitInfo.dist*rayDir));
            uv.z = 1.0f - uv.z;
            vec3 wallTexColor = texture(albedoMap, uv.xz).rgb;
            vec3 metallicColor = texture(metallicMap, uv.xz).rgb;

            hitInfo.albedo = wallTexColor.rgb;
            //hitInfo.albedo = vec3(uv.xz, 0.0f);
            hitInfo.emission = vec3(0.0f, 0.0f, 0.0f);
            hitInfo.specPercentage = metallicColor.r * 0.95f;
            //hitInfo.specPercentage = 0.0f;
            hitInfo.ior = 1.0f;
            hitInfo.isRefractive = false;
        }
    }

    // ceiling
    {
        vec3 A = vec3(-12.6f, 12.5f, -35.0f);
        vec3 B = vec3( 12.6f, 12.5f, -35.0f);
        vec3 C = vec3( 12.6f, 12.5f, -5.0f);
        vec3 D = vec3(-12.6f, 12.5f, -5.0f);
        if (QuadIntersect(rayPos, rayDir, hitInfo, A, B, C, D))
        {
            hitInfo.albedo = vec3(0.7f, 0.7f, 0.7f);
            hitInfo.emission = vec3(0.0f, 0.0f, 0.0f);
            hitInfo.specPercentage = 0.0f;
            hitInfo.ior = 1.0f;
            hitInfo.isRefractive = false;
        }
    }

    // left wall
    {
        vec3 A = vec3(-12.5f, -12.6f, -35.0f);
        vec3 B = vec3(-12.5f, -12.6f, -5.0f);
        vec3 C = vec3(-12.5f,  12.6f, -5.0f);
        vec3 D = vec3(-12.5f,  12.6f, -35.0f);
        if (QuadIntersect(rayPos, rayDir, hitInfo, A, B, C, D))
        {
            hitInfo.albedo = vec3(0.7f, 0.1f, 0.1f);
            hitInfo.emission = vec3(0.0f, 0.0f, 0.0f);
            hitInfo.specPercentage = 0.0f;
            hitInfo.ior = 1.0f;
            hitInfo.isRefractive = false;
        }
    }

    // right wall
    {
        vec3 A = vec3( 12.5f, -12.6f, -35.0f);
        vec3 B = vec3( 12.5f, -12.6f, -5.0f);
        vec3 C = vec3( 12.5f,  12.6f, -5.0f);
        vec3 D = vec3( 12.5f,  12.6f, -35.0f);
        if (QuadIntersect(rayPos, rayDir, hitInfo, A, B, C, D))
        {
            //hitInfo.albedo = vec3(0.1f, 0.7f, 0.1f);
            //hitInfo.albedo = vec3(0.1f, 0.1f, 0.7f);
            hitInfo.albedo = vec3(0.2f, 0.3f, 1.0f);
            hitInfo.emission = vec3(0.0f, 0.0f, 0.0f);
            hitInfo.specPercentage = 0.0f;
            hitInfo.ior = 1.0f;
            hitInfo.isRefractive = false;
        }
    }

    // light
    {
        vec3 A = vec3(-8.0f, 12.4f, -27.5f);
        vec3 B = vec3( 8.0f, 12.4f, -27.5f);
        vec3 C = vec3( 8.0f, 12.4f, -17.5f);
        vec3 D = vec3(-8.0f, 12.4f, -17.5f);
        //vec3 A = vec3(-5.0f, 0.4f, -17.5f);
        //vec3 B = vec3( 5.0f, 0.4f, -17.5f);
        //vec3 C = vec3( 5.0f, 8.4f, -17.5f);
        //vec3 D = vec3(-5.0f, 8.4f, -17.5f);
        if (QuadIntersect(rayPos, rayDir, hitInfo, A, B, C, D))
        {
            hitInfo.albedo = vec3(0.0f, 0.0f, 0.0f);
            hitInfo.emission = vec3(0.9f, 0.8f, 0.65f) * 5.0f;
            //hitInfo.emission = vec3(0.9f, 0.8f, 0.65f) * 2.0f;
            hitInfo.emission = vec3(0.0f);
            hitInfo.specPercentage = 0.0f;
            hitInfo.ior = 1.0f;
            hitInfo.isRefractive = false;
        }
    }

    float radius = 2.0f;
    float spacing = 2.5f * radius;
    int maxRow = 1;
    int maxCol = 4;
    // Sphere rows
    for (int i = 0; i < maxRow; ++i)
    {
        for (int j = 0; j <= maxCol; ++j)
        {
            {
                Sphere sphere;
                vec3 pos = vec3(spacing*j-10.0f, spacing*i-10.0f, -25.0f);
                sphere.pos = pos;
                sphere.radius = radius;
                if (SphereIntersect(rayPos, rayDir, hitInfo, sphere))
                {
                    //hitInfo.albedo = vec3(float(j)/maxCol, float(i)/maxRow, 0.8f);
                    hitInfo.albedo = vec3(0.8f);
                    hitInfo.emission = vec3(0.0f);
                    hitInfo.specPercentage = 0.0f;
                    hitInfo.ior = 1.1f + j*0.1f;
                    hitInfo.isRefractive = true;
                }
            }
        }
    }

    for (int i = 0; i < maxRow; ++i)
    {
        for (int j = 0; j <= maxCol; ++j)
        {
            {
                Sphere sphere;
                vec3 pos = vec3(spacing*j-10.0f, spacing*i-5.0f, -25.0f);
                sphere.pos = pos;
                sphere.radius = radius;
                if (SphereIntersect(rayPos, rayDir, hitInfo, sphere))
                {
                    //hitInfo.albedo = vec3(float(j)/maxCol, float(i)/maxRow, 0.8f);
                    hitInfo.albedo = vec3(0.8f);
                    hitInfo.emission = vec3(0.0f);
                    hitInfo.specPercentage = float(j)/float(maxCol);
                    hitInfo.ior = 1.0f;
                    hitInfo.isRefractive = false;
                }
            }
        }
    }
}

void CornellBoxSceneIntersection(in vec3 rayPos, in vec3 rayDir, inout RayHitInfo hitInfo)
{
    // back wall
    {
        vec3 A = vec3(-12.6f, -12.6f, -35.0f);
        vec3 B = vec3( 12.6f, -12.6f, -35.0f);
        vec3 C = vec3( 12.6f,  12.6f, -35.0f);
        vec3 D = vec3(-12.6f,  12.6f, -35.0f);
        if (QuadIntersect(rayPos, rayDir, hitInfo, A, B, C, D))
        {
            hitInfo.albedo = vec3(0.7f, 0.7f, 0.7f);
            hitInfo.emission = vec3(0.0f, 0.0f, 0.0f);
            hitInfo.specPercentage = 0.0f;
            hitInfo.ior = 1.0f;
        }
    }

    // floor
    {
        vec3 A = vec3(-12.6f, -12.45f, -35.0f);
        vec3 B = vec3( 12.6f, -12.45f, -35.0f);
        vec3 C = vec3( 12.6f, -12.45f, -5.0f);
        vec3 D = vec3(-12.6f, -12.45f, -5.0f);
        if (QuadIntersect(rayPos, rayDir, hitInfo, A, B, C, D))
        {
            hitInfo.albedo = vec3(0.7f, 0.7f, 0.7f);
            hitInfo.emission = vec3(0.0f, 0.0f, 0.0f);
            hitInfo.specPercentage = 0.0f;
            hitInfo.ior = 1.0f;
        }
    }

    // ceiling
    {
        vec3 A = vec3(-12.6f, 12.5f, -35.0f);
        vec3 B = vec3( 12.6f, 12.5f, -35.0f);
        vec3 C = vec3( 12.6f, 12.5f, -5.0f);
        vec3 D = vec3(-12.6f, 12.5f, -5.0f);
        if (QuadIntersect(rayPos, rayDir, hitInfo, A, B, C, D))
        {
            hitInfo.albedo = vec3(0.7f, 0.7f, 0.7f);
            hitInfo.emission = vec3(0.0f, 0.0f, 0.0f);
            hitInfo.specPercentage = 0.0f;
            hitInfo.ior = 1.0f;
        }
    }

    // left wall
    {
        vec3 A = vec3(-12.5f, -12.6f, -35.0f);
        vec3 B = vec3(-12.5f, -12.6f, -5.0f);
        vec3 C = vec3(-12.5f,  12.6f, -5.0f);
        vec3 D = vec3(-12.5f,  12.6f, -35.0f);
        if (QuadIntersect(rayPos, rayDir, hitInfo, A, B, C, D))
        {
            hitInfo.albedo = vec3(0.7f, 0.1f, 0.1f);
            hitInfo.emission = vec3(0.0f, 0.0f, 0.0f);
            hitInfo.specPercentage = 0.0f;
            hitInfo.ior = 1.0f;
        }
    }

    // right wall
    {
        vec3 A = vec3( 12.5f, -12.6f, -35.0f);
        vec3 B = vec3( 12.5f, -12.6f, -5.0f);
        vec3 C = vec3( 12.5f,  12.6f, -5.0f);
        vec3 D = vec3( 12.5f,  12.6f, -35.0f);
        if (QuadIntersect(rayPos, rayDir, hitInfo, A, B, C, D))
        {
            //hitInfo.albedo = vec3(0.1f, 0.7f, 0.1f);
            //hitInfo.albedo = vec3(0.1f, 0.1f, 0.7f);
            hitInfo.albedo = vec3(0.2f, 0.3f, 1.0f);
            hitInfo.emission = vec3(0.0f, 0.0f, 0.0f);
            hitInfo.specPercentage = 0.0f;
            hitInfo.ior = 1.0f;
        }
    }

    // light
    {
        vec3 A = vec3(-5.0f, 12.4f, -27.5f);
        vec3 B = vec3( 5.0f, 12.4f, -27.5f);
        vec3 C = vec3( 5.0f, 12.4f, -17.5f);
        vec3 D = vec3(-5.0f, 12.4f, -17.5f);
        if (QuadIntersect(rayPos, rayDir, hitInfo, A, B, C, D))
        {
            hitInfo.albedo = vec3(0.0f, 0.0f, 0.0f);
            hitInfo.emission = vec3(0.9f, 0.8f, 0.65f) * 5.0f;
            hitInfo.specPercentage = 0.0f;
            hitInfo.ior = 1.0f;
        }
    }

    { // left sphere
        Sphere sphere;
        sphere.pos = vec3(-3.5f, 2.5f, -25.0f);
        sphere.radius = 2.5f;
        if (SphereIntersect(rayPos, rayDir, hitInfo, sphere))
        {
            hitInfo.albedo = vec3(1.0f, 1.0f, 1.0f);
            hitInfo.emission = vec3(0.0f);
            hitInfo.specPercentage = 0.0f;
            hitInfo.ior = 1.0f;
        }
    }

    { // right sphere
        Sphere sphere;
        sphere.pos = vec3(3.5f, -9.0f, -25.0f);
        sphere.radius = 2.5f;
        if (SphereIntersect(rayPos, rayDir, hitInfo, sphere))
        {
            hitInfo.albedo = vec3(0.0f, 0.6f, 1.0f);
            hitInfo.emission = vec3(0.0f);
            hitInfo.specPercentage = 0.0f;
            hitInfo.ior = 1.0f;
        }
    }
}

vec3 RenderScene(inout vec3 rayO, inout vec3 rayD, inout uint rngState)
{
    vec3 accuColor = vec3(0.0f);
    vec3 currRayPos = rayO;
    vec3 currRayDir = rayD;
    vec3 colorMask = vec3(1.0f);
    const uint maxBounces = 8;
    for (int bounce = 0; bounce < maxBounces; ++bounce)
    {
        // Initialize Ray payload;
        RayHitInfo hitInfo = DefaultRayHitInfo();
        hitInfo.dist = infinity;
        hitInfo.fromInside = false;

        // Perform ray intersections on all scene objects
        CornellBoxSceneIntersection2(currRayPos, currRayDir, hitInfo);

        // Hit nothing within the scene
        if (hitInfo.dist == infinity) break;

        if (hitInfo.isRefractive) {
            currRayPos =
                (currRayPos + currRayDir*hitInfo.dist)
              - (hitInfo.normal * rayNudge);
        }
        else {
            currRayPos =
                (currRayPos + currRayDir*hitInfo.dist)
              + (hitInfo.normal * rayNudge);
        }
        // Calculate new ray pos by offsetting it slightly to prevent
        // self-intersections
        vec3 diffuseDir = normalize(hitInfo.normal + RandomUnitVector(rngState));
        vec3 specularDir = reflect(currRayDir, hitInfo.normal);

        if (hitInfo.isRefractive) {
            vec3 refractDir = refract(currRayDir, hitInfo.normal,
                    hitInfo.fromInside ? hitInfo.ior : 1.0f/hitInfo.ior
            );
            currRayDir = refractDir;
        }
        else {
            currRayDir = mix(diffuseDir, specularDir, hitInfo.specPercentage);
        }

        accuColor += hitInfo.emission * colorMask;
        if (!hitInfo.isRefractive)
            colorMask *= hitInfo.albedo;
    }

    return accuColor;
}

void main()
{
    uint rngState = uint(uint(gl_GlobalInvocationID.x)*uint(1835)
                       + uint(gl_GlobalInvocationID.y)*uint(3467)
                       + uint(pushConstants.frameNumber)*uint(24623))
                       | uint(1);

    // 1. Calculate uv
    ivec2 dim = imageSize(resultImage);
    vec2 uv = vec2(gl_GlobalInvocationID.xy) / dim;

    // Apply jitter for anti-aliasing
    vec2 jitter = vec2(RandomFloat01(rngState), RandomFloat01(rngState)) - 0.5f;
    float jitterFactor = 1.0f;
    vec2 uvJittered = vec2(jitterFactor*jitter + gl_GlobalInvocationID.xy) / dim;
    uv = uvJittered;

    // 2. Extract camera position from inverse view matrix
    mat4 invView = inverse(camera.view);
    vec3 rayOrigin = vec3(invView[3][0], invView[3][1], invView[3][2]);

    // 3. Convert uv to normalized device coordinates (clip space)
    vec4 ndcUV = vec4(uv*2.0f - 1.0f, 0.0f, 1.0f);
    //vec4 ndcUV = vec4(uv*2.0f - 1.0f, 0.0f, 1.0f);

    // 4. Convert from clip space to world space
    vec4 worldPos = inverse(camera.viewProj) * ndcUV;
    worldPos /= worldPos.w;

    // 5. Calculate world position ray direction
    //vec3 jitteredWorldPos = worldPos.xyz + vec3(jitter, 0.0f);
    vec3 rayDir = normalize(worldPos.xyz - rayOrigin);
    //vec3 rayDir = normalize(jitteredWorldPos.xyz - rayOrigin);
    //rayDir = normalize(rayDir + vec3(jitter, 0.0f));

    vec3 color = RenderScene(rayOrigin, rayDir, rngState);

    vec3 oldColor = imageLoad(resultImage, ivec2(gl_GlobalInvocationID.xy)).rgb;
    vec3 newColor = mix(oldColor, color, 1.0f/(pushConstants.frameNumber+1));
    imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), vec4(newColor, 1.0f));
}

// =========================================
void main1()
{
    // 1. Calculate uv
    ivec2 dim = imageSize(resultImage);
    vec2 uv = vec2(gl_GlobalInvocationID.xy) / dim;

    // 2. Extract camera position from inverse view matrix
    mat4 invView = inverse(camera.view);
    vec3 rayOrigin = vec3(invView[3][0],
                          invView[3][1],
                          invView[3][2]);

    // 3. Convert uv to normalized device coordinates (clip space)
    vec4 ndcUV = vec4(uv*2.0f - 1.0f, 0.0f, 1.0f);

    // 4. Convert from clip space to world space
    vec4 worldPos = inverse(camera.viewProj) * ndcUV;
    worldPos /= worldPos.w;

    // 5. Calculate world position ray direction
    vec3 rayDir = normalize(worldPos.xyz - rayOrigin);

    // 5. Store ray direction as a color
    vec3 color = rayDir;
    imageStore(resultImage,
        ivec2(gl_GlobalInvocationID.xy), vec4(color, 1.0f));
}
