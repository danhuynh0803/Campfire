#version 450

// =========================================
layout (local_size_x = 16, local_size_y = 16) in;
layout (set = 1, binding = 0, rgba8) uniform image2D resultImage;

const float epsilon = 0.001f;
const float infinity = 10000.0f;
const float rayNudge = 0.01f;
const float minimumRayHitDist = 0.01f;
const float c_pi = 3.14159265359f;
const float c_twopi = 2.0f * c_pi;

const int DIFF = 0;
const int REFL = 1;
const int REFR = 2;

uint wang_hash(inout uint seed)
{
    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));
    seed *= uint(9);
    seed = seed ^ (seed >> 4);
    seed *= uint(0x27d4eb2d);
    seed = seed ^ (seed >> 15);
    return seed;
}

float RandomFloat01(inout uint state)
{
    return float(wang_hash(state)) / 4294967296.0; // uint max
}

vec3 RandomUnitVector(inout uint state)
{
    float z = RandomFloat01(state) * 2.0f - 1.0f;
    float a = RandomFloat01(state) * c_twopi;
    float r = sqrt(1.0f - z * z);
    float x = r * cos(a);
    float y = r * sin(a);
    return vec3(x, y, z);
}

layout (push_constant) uniform PushConstants {
    uint frameNumber;
} pushConstants;

// =========================================
layout (set = 0, binding = 0) uniform Camera
{
    mat4 view;
    mat4 proj;
    mat4 viewProj;
} camera;

// =========================================
// TODO move to a global info
const int MAX_NUM_LIGHTS = 100;
struct Light
{
    vec4 pos;
    vec4 color;
    vec3 dir;
    float intensity;
};

layout (set = 0, binding = 1) uniform Lights
{
    Light lights[MAX_NUM_LIGHTS];
    uint numLights;
} lightBuffer;

struct RayHitInfo
{
    float dist;
    vec3 normal;
    vec3 albedo;
    vec3 emission;
    int material;
    float specPercentage;
    float ior; // index of refraction
    bool fromInside;
};

// =========================================
struct Sphere
{
    vec3 pos;
    float radius;
    vec3 emission;
    vec3 albedo;
    int mat;
    int id;
};


layout (std140, set = 2, binding = 0) buffer Spheres
{
    Sphere spheres[];
};

// =========================================
struct Quad
{
    vec3 a, b, c, d;
    vec3 emission;
    vec3 albedo;
    int mat;
    int id;
};

layout (std140, set = 2, binding = 1) buffer Quads
{
    Quad quads[];
};

float ScalarTriple(vec3 u, vec3 v, vec3 w)
{
    return dot(cross(u,v), w);
}

bool QuadIntersect(
    in vec3 rayPos,
    in vec3 rayDir,
    inout RayHitInfo info,
    in vec3 a,
    in vec3 b,
    in vec3 c,
    in vec3 d)
{
    // calculate normal and flip vertices order if needed
    vec3 normal = normalize(cross(c-a, c-b));
    if (dot(normal, rayDir) > 0.0f)
    {
        normal *= -1.0f;

        vec3 temp = d;
        d = a;
        a = temp;

        temp = b;
        b = c;
        c = temp;
    }

    vec3 p = rayPos;
    vec3 q = rayPos + rayDir;
    vec3 pq = q - p;
    vec3 pa = a - p;
    vec3 pb = b - p;
    vec3 pc = c - p;

    // determine which triangle to test against by testing against diagonal first
    vec3 m = cross(pc, pq);
    float v = dot(pa, m);
    vec3 intersectPos;
    if (v >= 0.0f)
    {
        // test against triangle a,b,c
        float u = -dot(pb, m);
        if (u < 0.0f) return false;
        float w = ScalarTriple(pq, pb, pa);
        if (w < 0.0f) return false;
        float denom = 1.0f / (u+v+w);
        u*=denom;
        v*=denom;
        w*=denom;
        intersectPos = u*a+v*b+w*c;
    }
    else
    {
        vec3 pd = d - p;
        float u = dot(pd, m);
        if (u < 0.0f) return false;
        float w = ScalarTriple(pq, pa, pd);
        if (w < 0.0f) return false;
        v = -v;
        float denom = 1.0f / (u+v+w);
        u*=denom;
        v*=denom;
        w*=denom;
        intersectPos = u*a+v*d+w*c;
    }

    float dist;
    if (abs(rayDir.x) > 0.1f)
    {
        dist = (intersectPos.x - rayPos.x) / rayDir.x;
    }
    else if (abs(rayDir.y) > 0.1f)
    {
        dist = (intersectPos.y - rayPos.y) / rayDir.y;
    }
    else
    {
        dist = (intersectPos.z - rayPos.z) / rayDir.z;
    }

    if (dist > minimumRayHitDist && dist < info.dist)
    {
        info.dist = dist;
        info.normal = normal;
        // TODO might be needed for 3d polygons, for now return false since quads are 2d
        //info.fromInside = false;
        return true;
    }

    return false;
}

bool SphereIntersect(
    in vec3 rayO,
    in vec3 rayD,
    inout RayHitInfo hitInfo,
    in Sphere sphere)
{
    vec3 oc = rayO - sphere.pos;
    float a = dot(rayD, rayD);
    float b = 2.0f * dot(oc, rayD);
    float c = dot(oc, oc) - sphere.radius*sphere.radius;

    // Roots exist if discriminant value >= 0
    float discr = b*b - 4*a*c;
    if (discr < 0.0f) {
        return false;
    }

    float invDenom = 0.5f / a; // 1/(2a)
    bool isInside = false;
    float dist = (-b - sqrt(discr)) * invDenom;
    if (dist < 0.0f)
    {
        isInside = true;
        dist = (-b + sqrt(discr)) * invDenom;
    }

    // Get closest value of intersection which is stored as lowest t value
    if (dist > minimumRayHitDist && dist < hitInfo.dist)
    {
        hitInfo.dist = dist;
        vec3 hitPos = rayO + dist*rayD;
        hitInfo.normal = normalize(hitPos - sphere.pos)
                       * (isInside ? -1.0f : 1.0f);
        hitInfo.fromInside = isInside;
        return true;
    }

    return false;
}

void FurnaceTest(in vec3 rayPos, in vec3 rayDir, inout RayHitInfo hitInfo)
{
    { // Surrounding sphere
        Sphere sphere;
        sphere.pos = vec3(0.0f);
        sphere.radius = 20.0f;
        if (SphereIntersect(rayPos, rayDir, hitInfo, sphere))
        {
            hitInfo.albedo = vec3(0.18f);
            hitInfo.emission = vec3(0.0f);
            hitInfo.specPercentage = 0.0f;
            hitInfo.ior = 1.0f;
        }
    }

    { // light
        Sphere sphere;
        sphere.pos = vec3(0.0f);
        sphere.radius = 100.0f;
        if (SphereIntersect(rayPos, rayDir, hitInfo, sphere))
        {
            hitInfo.albedo = vec3(0.8f, 0.7f, 0.5f);
            hitInfo.emission = vec3(1.0f) * 5.0f;
            hitInfo.specPercentage = 0.0f;
            hitInfo.ior = 1.0f;
        }
    }
}

vec2 GetUv(vec3 minBound, vec3 maxBound, vec3 pos)
{
    vec3 dim = maxBound - minBound;
    vec2 uv = (pos.xy - minBound.xy)/dim.xy;
    return uv;
}

void CornellBoxSceneIntersection2(in vec3 rayPos, in vec3 rayDir, inout RayHitInfo hitInfo)
{
    // TODO
    //vec3 minBound = vec3(0.0f);
    //vec3 maxBound = vec3(20.0f, 30.0f, -35.0f);

    float scalar = 1.0f;
    // back wall
    {
        vec3 A = vec3(-12.6f, -12.6f, -35.0f);
        vec3 B = vec3( 12.6f, -12.6f, -35.0f);
        vec3 C = vec3( 12.6f,  12.6f, -35.0f);
        vec3 D = vec3(-12.6f,  12.6f, -35.0f);
        if (QuadIntersect(rayPos, rayDir, hitInfo, A, B, C, D))
        {
            vec2 uv = GetUv(A, C, (rayPos + hitInfo.dist*rayDir));
            vec2 maxTiles = ivec2(5, 5);
            uv *= maxTiles;
            vec2 iuv = floor(uv);

            bool isTiled =
                mod(iuv.x + iuv.y, 2) == 0
            ;

            vec3 tileColor = isTiled
                ? vec3(0.2f,0.8f,1.0f)
                : vec3(1.0f,0.8f,0.7f)
            ;
            hitInfo.albedo = tileColor;
            hitInfo.emission = isTiled ? vec3(0.0f) : hitInfo.albedo * 5.0f;
            //hitInfo.emission = vec3(0.0f);
            hitInfo.specPercentage = isTiled ? 1.0f : 0.0f;
            hitInfo.ior = 1.0f;
        }
    }

    // floor
    {
        vec3 A = vec3(-12.6f, -12.45f, -35.0f);
        vec3 B = vec3( 12.6f, -12.45f, -35.0f);
        vec3 C = vec3( 12.6f, -12.45f, -5.0f);
        vec3 D = vec3(-12.6f, -12.45f, -5.0f);
        if (QuadIntersect(rayPos, rayDir, hitInfo, A, B, C, D))
        {
            hitInfo.albedo = vec3(0.7f, 0.7f, 0.7f);
            hitInfo.emission = vec3(0.0f, 0.0f, 0.0f);
            //hitInfo.specPercentage = 0.9f;
            hitInfo.specPercentage = 0.0f;
            hitInfo.ior = 1.0f;
        }
    }

    // ceiling
    {
        vec3 A = vec3(-12.6f, 12.5f, -35.0f);
        vec3 B = vec3( 12.6f, 12.5f, -35.0f);
        vec3 C = vec3( 12.6f, 12.5f, -5.0f);
        vec3 D = vec3(-12.6f, 12.5f, -5.0f);
        if (QuadIntersect(rayPos, rayDir, hitInfo, A, B, C, D))
        {
            hitInfo.albedo = vec3(0.7f, 0.7f, 0.7f);
            hitInfo.emission = vec3(0.0f, 0.0f, 0.0f);
            hitInfo.specPercentage = 0.0f;
            hitInfo.ior = 1.0f;
        }
    }

    // left wall
    {
        vec3 A = vec3(-12.5f, -12.6f, -35.0f);
        vec3 B = vec3(-12.5f, -12.6f, -5.0f);
        vec3 C = vec3(-12.5f,  12.6f, -5.0f);
        vec3 D = vec3(-12.5f,  12.6f, -35.0f);
        if (QuadIntersect(rayPos, rayDir, hitInfo, A, B, C, D))
        {
            hitInfo.albedo = vec3(0.7f, 0.1f, 0.1f);
            hitInfo.emission = vec3(0.0f, 0.0f, 0.0f);
            hitInfo.specPercentage = 0.0f;
            hitInfo.ior = 1.0f;
        }
    }

    // right wall
    {
        vec3 A = vec3( 12.5f, -12.6f, -35.0f);
        vec3 B = vec3( 12.5f, -12.6f, -5.0f);
        vec3 C = vec3( 12.5f,  12.6f, -5.0f);
        vec3 D = vec3( 12.5f,  12.6f, -35.0f);
        if (QuadIntersect(rayPos, rayDir, hitInfo, A, B, C, D))
        {
            //hitInfo.albedo = vec3(0.1f, 0.7f, 0.1f);
            //hitInfo.albedo = vec3(0.1f, 0.1f, 0.7f);
            hitInfo.albedo = vec3(0.2f, 0.3f, 1.0f);
            hitInfo.emission = vec3(0.0f, 0.0f, 0.0f);
            hitInfo.specPercentage = 0.0f;
            hitInfo.ior = 1.0f;
        }
    }

    // light
    {
        vec3 A = vec3(-5.0f, 12.4f, -27.5f);
        vec3 B = vec3( 5.0f, 12.4f, -27.5f);
        vec3 C = vec3( 5.0f, 12.4f, -17.5f);
        vec3 D = vec3(-5.0f, 12.4f, -17.5f);
        if (QuadIntersect(rayPos, rayDir, hitInfo, A, B, C, D))
        {
            hitInfo.albedo = vec3(0.0f, 0.0f, 0.0f);
            hitInfo.emission = vec3(0.9f, 0.8f, 0.65f) * 5.0f;
            hitInfo.specPercentage = 0.0f;
            hitInfo.ior = 1.0f;
        }
    }

    float radius = 2.0f;
    float spacing = 2.5f * radius;
    int maxRow = 1;
    int maxCol = 4;
    for (int i = 0; i < maxRow; ++i)
    {
        for (int j = 0; j <= maxCol; ++j)
        {
            {
                Sphere sphere;
                vec3 pos = vec3(spacing*j-10.0f, spacing*i-5.0f, -25.0f);
                sphere.pos = pos;
                sphere.radius = radius;
                if (SphereIntersect(rayPos, rayDir, hitInfo, sphere))
                {
                    //hitInfo.albedo = vec3(float(j)/maxCol, float(i)/maxRow, 0.8f);
                    hitInfo.albedo = vec3(0.8f);
                    hitInfo.emission = vec3(0.0f);
                    hitInfo.specPercentage = 0.0f;
                    hitInfo.ior = 1.0f + j*0.1f;
                }
            }
        }
    }

    for (int i = 0; i < maxRow; ++i)
    {
        for (int j = 0; j <= maxCol; ++j)
        {
            {
                Sphere sphere;
                vec3 pos = vec3(spacing*j-10.0f, spacing*i-10.0f, -25.0f);
                sphere.pos = pos;
                sphere.radius = radius;
                if (SphereIntersect(rayPos, rayDir, hitInfo, sphere))
                {
                    //hitInfo.albedo = vec3(float(j)/maxCol, float(i)/maxRow, 0.8f);
                    hitInfo.albedo = vec3(0.8f);
                    hitInfo.emission = vec3(0.0f);
                    hitInfo.specPercentage = float(j)/float(maxCol);
                    hitInfo.ior = 1.0f;
                }
            }
        }
    }
}

void CornellBoxSceneIntersection(in vec3 rayPos, in vec3 rayDir, inout RayHitInfo hitInfo)
{
    float scalar = 1.0f;
    // back wall
    {
        vec3 A = scalar * vec3(-12.6f, -12.6f, -35.0f);
        vec3 B = scalar * vec3( 12.6f, -12.6f, -35.0f);
        vec3 C = scalar * vec3( 12.6f,  12.6f, -35.0f);
        vec3 D = scalar * vec3(-12.6f,  12.6f, -35.0f);
        if (QuadIntersect(rayPos, rayDir, hitInfo, A, B, C, D))
        {
            hitInfo.albedo = vec3(0.7f, 0.7f, 0.7f);
            hitInfo.emission = vec3(0.0f, 0.0f, 0.0f);
            hitInfo.specPercentage = 0.0f;
            hitInfo.ior = 1.0f;
        }
    }

    // front wall
    //{
    //    float wallScalar = 0.5f;
    //    vec3 A = vec3(-12.6f*wallScalar, -12.6f*wallScalar, -5.0f);
    //    vec3 B = vec3( 12.6f*wallScalar, -12.6f*wallScalar, -5.0f);
    //    vec3 C = vec3( 12.6f*wallScalar,  12.6f*wallScalar, -5.0f);
    //    vec3 D = vec3(-12.6f*wallScalar,  12.6f*wallScalar, -5.0f);
    //    if (QuadIntersect(rayPos, rayDir, hitInfo, A, B, C, D))
    //    {
    //        hitInfo.albedo = vec3(0.7f, 0.7f, 0.7f);
    //        hitInfo.emission = vec3(0.0f, 0.0f, 0.0f);
    //        hitInfo.specPercentage = 1.0f;
    //        hitInfo.ior = 1.12;
    //    }
    //}


    // back wall mirror
    //{
    //    vec3 A = vec3(-5.6f, -5.6f, -34.9f);
    //    vec3 B = vec3( 5.6f, -5.6f, -34.9f);
    //    vec3 C = vec3( 5.6f,  5.6f, -34.9f);
    //    vec3 D = vec3(-5.6f,  5.6f, -34.9f);
    //    if (QuadIntersect(rayPos, rayDir, hitInfo, A, B, C, D))
    //    {
    //        hitInfo.albedo = vec3(0.7f, 0.7f, 0.7f);
    //        hitInfo.emission = vec3(0.0f, 0.0f, 0.0f);
    //        hitInfo.specPercentage = 1.0f;
    //    }
    //}

    // floor
    {
        vec3 A = scalar * vec3(-12.6f, -12.45f, -35.0f);
        vec3 B = scalar * vec3( 12.6f, -12.45f, -35.0f);
        vec3 C = scalar * vec3( 12.6f, -12.45f, -5.0f);
        vec3 D = scalar * vec3(-12.6f, -12.45f, -5.0f);
        if (QuadIntersect(rayPos, rayDir, hitInfo, A, B, C, D))
        {
            hitInfo.albedo = vec3(0.7f, 0.7f, 0.7f);
            hitInfo.emission = vec3(0.0f, 0.0f, 0.0f);
            //hitInfo.specPercentage = 0.9f;
            hitInfo.specPercentage = 0.0f;
            hitInfo.ior = 1.0f;
        }
    }

    // ceiling
    {
        vec3 A = scalar * vec3(-12.6f, 12.5f, -35.0f);
        vec3 B = scalar * vec3( 12.6f, 12.5f, -35.0f);
        vec3 C = scalar * vec3( 12.6f, 12.5f, -5.0f);
        vec3 D = scalar * vec3(-12.6f, 12.5f, -5.0f);
        if (QuadIntersect(rayPos, rayDir, hitInfo, A, B, C, D))
        {
            hitInfo.albedo = vec3(0.7f, 0.7f, 0.7f);
            hitInfo.emission = vec3(0.0f, 0.0f, 0.0f);
            hitInfo.specPercentage = 0.0f;
            hitInfo.ior = 1.0f;
        }
    }

    // left wall
    {
        vec3 A = scalar * vec3(-12.5f, -12.6f, -35.0f);
        vec3 B = scalar * vec3(-12.5f, -12.6f, -5.0f);
        vec3 C = scalar * vec3(-12.5f,  12.6f, -5.0f);
        vec3 D = scalar * vec3(-12.5f,  12.6f, -35.0f);
        if (QuadIntersect(rayPos, rayDir, hitInfo, A, B, C, D))
        {
            hitInfo.albedo = vec3(0.7f, 0.1f, 0.1f);
            hitInfo.emission = vec3(0.0f, 0.0f, 0.0f);
            hitInfo.specPercentage = 0.95f;
            hitInfo.ior = 1.0f;
        }
    }

    // right wall
    {
        vec3 A = scalar * vec3( 12.5f, -12.6f, -35.0f);
        vec3 B = scalar * vec3( 12.5f, -12.6f, -5.0f);
        vec3 C = scalar * vec3( 12.5f,  12.6f, -5.0f);
        vec3 D = scalar * vec3( 12.5f,  12.6f, -35.0f);
        if (QuadIntersect(rayPos, rayDir, hitInfo, A, B, C, D))
        {
            //hitInfo.albedo = vec3(0.1f, 0.7f, 0.1f);
            //hitInfo.albedo = vec3(0.1f, 0.1f, 0.7f);
            hitInfo.albedo = vec3(0.2f, 0.3f, 1.0f);
            hitInfo.emission = vec3(0.0f, 0.0f, 0.0f);
            hitInfo.specPercentage = 0.95f;
            hitInfo.ior = 1.0f;
        }
    }

    // light
    {
        vec3 A = scalar * vec3(-5.0f, 12.4f, -27.5f);
        vec3 B = scalar * vec3( 5.0f, 12.4f, -27.5f);
        vec3 C = scalar * vec3( 5.0f, 12.4f, -17.5f);
        vec3 D = scalar * vec3(-5.0f, 12.4f, -17.5f);
        if (QuadIntersect(rayPos, rayDir, hitInfo, A, B, C, D))
        {
            hitInfo.albedo = vec3(0.0f, 0.0f, 0.0f);
            hitInfo.emission = vec3(0.9f, 0.8f, 0.65f) * 5.0f;
            hitInfo.specPercentage = 0.0f;
            hitInfo.ior = 1.0f;
        }
    }

    //{ // left sphere light
    //    Sphere sphere;
    //    sphere.pos = vec3(-3.5f, 6.0f, -25.0f);
    //    sphere.radius = 1.0f;
    //    if (SphereIntersect(rayPos, rayDir, hitInfo, sphere))
    //    {
    //        hitInfo.albedo = vec3(1.0f, 1.0f, 1.0f);
    //        hitInfo.emission = vec3(0.0f, 1.0f, 0.0f) * 20.0f;
    //        hitInfo.specPercentage = 0.0f;
    //        hitInfo.ior = 1.0f;
    //    }
    //}


    { // left sphere
        Sphere sphere;
        sphere.pos = vec3(-3.5f, 2.5f, -25.0f);
        sphere.radius = 2.5f;
        if (SphereIntersect(rayPos, rayDir, hitInfo, sphere))
        {
            hitInfo.albedo = vec3(1.0f, 1.0f, 1.0f);
            hitInfo.emission = vec3(0.0f);
            hitInfo.specPercentage = 1.0f;
            hitInfo.ior = 1.0f;
        }
    }

    { // glass sphere
        Sphere sphere;
        sphere.pos = vec3(-5.0f, -9.0f, -10.0f);
        sphere.radius = 3.5f;
        if (SphereIntersect(rayPos, rayDir, hitInfo, sphere))
        {
            hitInfo.albedo = vec3(1.0f, 1.0f, 1.0f);
            hitInfo.emission = vec3(0.0f);
            hitInfo.specPercentage = 0.0f;
            hitInfo.ior = 1.4f;
        }
    }

    { // yellow sphere
        Sphere sphere;
        sphere.pos = vec3(-5.0f, -7.5f, -30.0f);
        sphere.radius = 5.0f;
        if (SphereIntersect(rayPos, rayDir, hitInfo, sphere))
        {
            hitInfo.albedo = vec3(1.0f, 0.8f, 0.2f);
            hitInfo.emission = vec3(0.0f);
            hitInfo.specPercentage = 1.0f;
            hitInfo.ior = 1.0f;
        }
    }

    { // blue sphere
        Sphere sphere;
        sphere.pos = vec3(-2.0f, -10.5f, -17.0f);
        sphere.radius = 2.0f;
        if (SphereIntersect(rayPos, rayDir, hitInfo, sphere))
        {
            hitInfo.albedo = vec3(0.2f, 0.8f, 0.9f);
            hitInfo.emission = vec3(0.0f);
            hitInfo.specPercentage = 0.4f;
            hitInfo.ior = 1.0f;
        }
    }

    { // right sphere
        Sphere sphere;
        sphere.pos = vec3(3.5f, -9.0f, -25.0f);
        sphere.radius = 2.5f;
        if (SphereIntersect(rayPos, rayDir, hitInfo, sphere))
        {
            hitInfo.albedo = vec3(0.0f, 0.6f, 1.0f);
            hitInfo.emission = vec3(0.0f);
            hitInfo.specPercentage = 0.0f;
            hitInfo.ior = 1.33f;
        }
    }

    //{ // sphere light
    //    Sphere sphere;
    //    sphere.pos = vec3(10.0f, 1.0f, -20.0f);
    //    sphere.radius = 1.0f;
    //    if (SphereIntersect(rayPos, rayDir, hitInfo, sphere))
    //    {
    //        hitInfo.albedo = vec3(0.0f);
    //        hitInfo.emission = vec3(1.0f, 0.8f, 0.7f) * 20.0f;
    //    }
    //}
}

vec3 RenderScene(inout vec3 rayO, inout vec3 rayD, inout uint rngState)
{
    vec3 accuColor = vec3(0.0f);
    vec3 currRayPos = rayO;
    vec3 currRayDir = rayD;
    vec3 colorMask = vec3(1.0f);

    const uint maxBounces = 8;
    for (int bounce = 0; bounce < maxBounces; ++bounce)
    {
        RayHitInfo hitInfo;
        hitInfo.dist = infinity;
        hitInfo.fromInside = false;

        //CornellBoxSceneIntersection(currRayPos, currRayDir, hitInfo);
        CornellBoxSceneIntersection2(currRayPos, currRayDir, hitInfo);

        // Hit nothing within the scene
        if (hitInfo.dist == infinity)
            break;


        // TODO use bool for enabling refraction
        if (hitInfo.ior > 1.01f)
        {
            currRayPos =
                (currRayPos + currRayDir*hitInfo.dist)
              - (hitInfo.normal * rayNudge)
            ;
        }
        else
        {
            currRayPos =
                (currRayPos + currRayDir*hitInfo.dist)
              + (hitInfo.normal * rayNudge)
            ;

        }
        // Calculate new ray pos by offsetting it slightly to prevent
        // self-intersections
        vec3 diffuseDir = normalize(hitInfo.normal + RandomUnitVector(rngState));
        vec3 specularDir = reflect(currRayDir, hitInfo.normal);

        if (hitInfo.ior > 1.01f) {
            vec3 refractDir = refract(currRayDir, hitInfo.normal,
                    hitInfo.fromInside ? hitInfo.ior : 1.0f/hitInfo.ior
            );
            currRayDir = refractDir;
        }
        else {
            currRayDir = mix(diffuseDir, specularDir, hitInfo.specPercentage);
        }

        //if (hitInfo.material == REFL) {
        //    accuColor = currRayDir;
        //    break;
        //}
        //if (bounce == 1)
        //{
        //    accuColor = hitInfo.albedo;
        //    break;
        //}

        accuColor += hitInfo.emission * colorMask;
        if (hitInfo.ior < 1.01f)
            colorMask *= hitInfo.albedo;
    }

    return accuColor;
}

void main()
{
    uint rngState = uint(uint(gl_GlobalInvocationID.x)*uint(1835)
                       + uint(gl_GlobalInvocationID.y)*uint(3467)
                       + uint(pushConstants.frameNumber)*uint(24623))
                       | uint(1);

    // 1. Calculate uv
    ivec2 dim = imageSize(resultImage);
    vec2 uv = vec2(gl_GlobalInvocationID.xy) / dim;

    // Apply jitter for anti aliasting
    vec2 jitter = vec2(RandomFloat01(rngState), RandomFloat01(rngState)) - 0.5f;
    float jitterFactor = 1.0f;
    //jitterFactor = 5.0f;
    vec2 uvJittered = vec2(jitterFactor*jitter + gl_GlobalInvocationID.xy) / dim;
    uv = uvJittered;

    // 2. Extract camera position from inverse view matrix
    mat4 invView = inverse(camera.view);
    vec3 rayOrigin = vec3(invView[3][0], invView[3][1], invView[3][2]);

    // 3. Convert uv to normalized device coordinates (clip space)
    vec4 ndcUV = vec4(uv*2.0f - 1.0f, 0.0f, 1.0f);
    //vec4 ndcUV = vec4(uv*2.0f - 1.0f, 0.0f, 1.0f);

    // 4. Convert from clip space to world space
    vec4 worldPos = inverse(camera.viewProj) * ndcUV;
    worldPos /= worldPos.w;

    // 5. Calculate world position ray direction
    //vec3 jitteredWorldPos = worldPos.xyz + vec3(jitter, 0.0f);
    vec3 rayDir = normalize(worldPos.xyz - rayOrigin);
    //vec3 rayDir = normalize(jitteredWorldPos.xyz - rayOrigin);
    //rayDir = normalize(rayDir + vec3(jitter, 0.0f));


    vec3 color = RenderScene(rayOrigin, rayDir, rngState);

    // tonemapping
    //color = color / (vec3(1)+color);
    vec3 oldColor = imageLoad(resultImage, ivec2(gl_GlobalInvocationID.xy)).rgb;
    //oldColor = oldColor / (vec3(1)+oldColor);

    vec3 newColor = mix(oldColor, color, 1.0f/(pushConstants.frameNumber+1));
    //if (pushConstants.frameNumber >= 100)
    //    newColor = oldColor;
    //
    //newColor = rayDir;

    imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), vec4(newColor, 1.0f));
}

// =========================================
void main1()
{
    // 1. Calculate uv
    ivec2 dim = imageSize(resultImage);
    vec2 uv = vec2(gl_GlobalInvocationID.xy) / dim;

    // 2. Extract camera position from inverse view matrix
    mat4 invView = inverse(camera.view);
    vec3 rayOrigin = vec3(invView[3][0],
                          invView[3][1],
                          invView[3][2]);

    // 3. Convert uv to normalized device coordinates (clip space)
    vec4 ndcUV = vec4(uv*2.0f - 1.0f, 0.0f, 1.0f);

    // 4. Convert from clip space to world space
    vec4 worldPos = inverse(camera.viewProj) * ndcUV;
    worldPos /= worldPos.w;

    // 5. Calculate world position ray direction
    vec3 rayDir = normalize(worldPos.xyz - rayOrigin);

    // 5. Store ray direction as a color
    vec3 color = rayDir;
    imageStore(resultImage,
        ivec2(gl_GlobalInvocationID.xy), vec4(color, 1.0f));
}
